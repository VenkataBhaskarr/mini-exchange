/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import java.util.Scanner;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.List;

public class App {
    private static int PROCESSING_THREADS = 5;
    private static List<Stock> stocks;
    private static List<Order> orders;
    private static List<Transaction> transactions;
    private static ReentrantLock transactionLock;
    public static void main(String[] args) {
        // String a = args[0];
       Scanner sc = new Scanner(System.in);
       stocks = new ArrayList<>();
       Stock stock1 = new Stock();
       stock1.setName("RELIANCE");
       stocks.add(stock1);
       Stock stock2 = new Stock();
       stock2.setName("TCS");
       stocks.add(stock2);
       Stock stock3  = new Stock();
       stock3.setName("HDFCBANK");
       stocks.add(stock3);
       Stock stock4  = new Stock();
       stock4.setName("ITC");
       stocks.add(stock4);
       Stock stock5  = new Stock();
       stock5.setName("INFY");
       stocks.add(stock5);
       orders = new ArrayList<>();
       transactions = new ArrayList<>();
       transactionLock = new ReentrantLock();

       while(true){
         System.out.println("1. Enter as trader into the exchange ?");
         System.out.println("2. Enter as Admin into the exchange ?");
         System.out.println("3. Exit !");
         String input = sc.nextLine();
         switch (input) {
            case "1": {
                gameStartsAsTrader(sc);
                break;
            }
            case "2": {
                gameStartsAsAdmin(sc);
                break;
            }
            case "3": {
                return;
            }
            default: {
                break;
            }
         }
         
       }
    }

    public static void gameStartsAsAdmin(Scanner sc){
        System.out.println("1. Enter new entry in stock? ");
        System.out.println("2. Check the transactions? ");
        String input = sc.nextLine();
        switch (input) {
            case "1": {
                Stock stock = new Stock();
                System.out.println("Enter stock name : ");
                String s_name = sc.nextLine();
                stock.setName(s_name);
                // System.out.println("enter stock quantity : ");
                // long s_quantity = sc.nextLong();
                // sc.nextLine();
                // stock.setAvailableQuantity(s_quantity);
                // System.out.println("Enter the stock price : ");
                // double stock_price = sc.nextDouble();
                // sc.nextLine();
                // stock.setPrice(stock_price);
                stocks.add(stock);
                break;
            }
            case "2": {
                printTransactions();
            }
            default:
                break;
        }

        return;
    }

    public static void printTransactions(){
        for(Transaction transaction: transactions){
            transaction.printTransaction();
        }
        System.out.println(transactions.size());
    }

    public static void gameStartsAsTrader(Scanner sc){
        System.out.println("1. Seach the available stocks?");
        System.out.println("2. Check the order book of certain stock?");
        System.out.println("3. Place an order CSV");
        System.out.println("4. Exit");
        String order = sc.nextLine();
        switch(order) {
            case "1" : {
                listAllStocks();
                break;
            }
            case "2" : {
                String stockname = sc.nextLine();
                stockOrderBook(stockname);
                break;
            }
            case "3" : {
                handleCSVOrders();
                break;
            }
            case "4" : {
                return;
            }
            default : {
                break;
            }
        }
    }

    public static void handleOrderLines(List<String> lines){
        for(String line : lines){
            handleOrder(line);
        }
    }

    public static void handleCSVOrders(){
        File file = new File("/Users/apple/Desktop/dev/exchange-java/app/data/orders.csv");

        try{
            ExecutorService service = Executors.newFixedThreadPool(PROCESSING_THREADS);
            BufferedReader br = new BufferedReader(new FileReader(file));
            String line;
            List<String> lines = new ArrayList<>();
            while((line = br.readLine())  != null){
                final String line_opt = line;
                lines.add(line_opt);
            }
            CountDownLatch latch = new CountDownLatch(lines.size());
            for(String single_line: lines){
               service.execute(() -> {
                 try{
                    handleOrder(single_line);
                 }finally{
                    latch.countDown();
                 }
               });
            }
            
            if(latch.await(10000, TimeUnit.MILLISECONDS)){
                service.shutdown();
                br.close();
            }else{
                System.out.println("Timeout threads are yet to complete");
                service.shutdown();
                br.close();
            }
            // if(latch.await(20, TimeUnit.SECONDS)){
            //    Thread.sleep(500);
            //    //System.out.println("reached end of all threads");
            //    service.shutdown();
            //    //System.out.println("service shutdown");
            // }else{
            //     System.out.println("waiting for threads to complete");
            // }

            // br.close();
           
        }catch(Exception e){
            System.out.println(e);
            return;
        }
    }

    public static void handleOrder(String line){
        //System.out.println(line + " is handling by " + Thread.currentThread().getName());
        String[] orderInfo = line.split(",");
        List<String> cleanOrderInfo = new ArrayList<>();
        if(orderInfo.length < 4) return;

        for(String info: orderInfo){
            if(info.equals("") || info.equals(" ")){
                //skip
            }else{
                cleanOrderInfo.add(info);
            }
        }
        Order order = new Order(cleanOrderInfo.get(0),
                  cleanOrderInfo.get(1),
                  Integer.parseInt(cleanOrderInfo.get(2)),
                  Double.parseDouble(cleanOrderInfo.get(3)));

        //order.printOrder();
        //System.out.println(order.getStock() + " is handling by " + Thread.currentThread().getName());
        // // START, Please optimize the code from here
        Stock stock = null;

        for(Stock stk: stocks){
            if(stk.getName().equals(order.getStock())){
                stock = stk;
            }
        }

        synchronized(stock){
            if(order.getType().strip().equals("BUY")){
                //System.out.println("adding buy order for stock " + order.getStock());
                stock.addBuyOrder(order);
            }else{
                //System.out.println("adding sell order for stock " + order.getStock());
                stock.addSellOrder(order);
            }
            processOrderBookOfTheStock(stock);
        }
        // END.

    }

    public static void processOrderBookOfTheStock(Stock stock){
        // Keep processing until no more matches are possible
        while(true) {
            // Peek at the top orders without removing them
            Order buyorder = stock.getBuyOrderPeek();
            Order sellorder = stock.getSellOrderPeek();

            // If either side is empty, exit
            if(buyorder == null || sellorder == null) {
                return;
            }
            
            // Check if a match is possible (buy price >= sell price)
            if(buyorder.getPrice() >= sellorder.getPrice()){
                // Now that we know there's a match, actually remove the orders
                buyorder = stock.pollBuyOrder();
                sellorder = stock.pollSellOrder();
                
                // Double-check they're still there (another thread might have taken them)
                if(buyorder == null || sellorder == null) {
                    // Put back any that we got
                    if(buyorder != null) stock.addBuyOrder(buyorder);
                    if(sellorder != null) stock.addSellOrder(sellorder);
                    continue;
                }
                
                // Execute the trade at the sell price (market convention)
                double tradePrice = sellorder.getPrice();
                int tradeQuantity = Math.min(buyorder.getQuantity(), sellorder.getQuantity());
                
                stock.setCurrentPrice(tradePrice);
                
                // Handle partial fills
                if(buyorder.getQuantity() > sellorder.getQuantity()){
                    // Buy order partially filled, sell order completely filled
                    int remainingQuantity = buyorder.getQuantity() - sellorder.getQuantity();
                    buyorder.setQuantity(remainingQuantity);
                    stock.addBuyOrder(buyorder);  // Put back the remaining buy order
                    // sellorder is completely consumed, don't put it back
                }else if(buyorder.getQuantity() < sellorder.getQuantity()){
                    // Sell order partially filled, buy order completely filled
                    int remainingQuantity = sellorder.getQuantity() - buyorder.getQuantity();
                    sellorder.setQuantity(remainingQuantity);
                    stock.addSellOrder(sellorder);  // Put back the remaining sell order
                    // buyorder is completely consumed, don't put it back
                }else{
                    // Both orders completely filled, don't put either back
                }
                
                // Record the transaction
                transactionLock.lock();
                try {
                    Transaction transaction = new Transaction(stock.getName(), tradePrice);  
                    transactions.add(transaction);
                }finally{
                    transactionLock.unlock();
                }
                
                // Continue the loop to check for more matches
            } else {
                // No match possible, exit (orders remain in queues)
                return;
            }
        }
    }

    public static void stockOrderBook(String stock_name){
       for(Stock stock: stocks){
        if(stock.getName().equals(stock_name)){
             stock.printBuyOrders();
             stock.printSellOrders();
        }
       }
    }
    
    public static void listAllStocks(){
        for(Stock stock: stocks){
            System.out.println(stock.getName());
        }
    }
}
